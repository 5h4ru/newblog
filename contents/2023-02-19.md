---
title: "2023-02-22 details 記法の実装"
date: "2023-02-22"
---

とりあえず HTML に変換できた：

---

:::details タイトル

中身

:::details nest

ネストした details

:::

:::

---

## MD → MDAST

実装に一番苦労した点は、上のように `details` 記法がネストしている場合の変換処理である。

結論から言えば、ライブラリが DFS で探索することを利用し、スタックを利用したアルゴリズムを実装した。ままよくある再帰処理である。

具体的には、 `unist-util-visit-parents` で `text` ノードを見つつ、中身が `:::details` で始まるノード（以下「開始ノード」という）があれば、その index をスタックに push する。中身が `:::` だけのノード（以下「終了ノード」という）を見つけたら、スタックから pop した index が対応するノードとなる。これで開始ノードと終了ノードの位置が分かるので、その間のノードを開始ノードの children にすれば良い（終了ノードは要らないので抹消する）。 正しい記法で書かれているならば、この方法で問題なく生成できる。正しい記法で書かれていなければ、例外処理をしていないので当然バグるだろうが、書くのは俺だけなので問題はないだろう。また言うまでもないが、 2 重どころでなくても、もっと多重にネストしていても正しく動作するだろう。

タイトル部分は正規表現で抽出して開始ノードの適当なプロパティに入れておけば良い（これは hast に変換する際に使う）。

### もうちょっと詳しい話

```
:::details タイトル
内容
:::
```

と書けば、これは

```js
{
    type: 'paragraph',
    children: [ { type: 'text', value: ':::details タイトル\n内容\n:::', position: [Object] } ],
    position: { 省略 }
}
```

のような mdast に変換される。
この場合なら、単に `paragraph` ノードの type を書き換え、 value をいい感じにスライスすれば事足りる。問題は以下のように記述した場合である：

```
:::detail タイトル

内容

:::
```

Markdown の仕様として、空行の区切りが `<p>` の区切りとなるのが一般的である。ゆえに、前述の記述は mdast では以下のようになる：

```js
{
    type: 'paragraph',
    children: [ { type: 'text', value: ':::details タイトル', position: [Object] } ],
    position: { 省略 }
}
{
    type: 'paragraph',
    children: [ { type: 'text', value: '内容', position: [Object] } ],
    position: { 省略 }
}
{
    type: 'paragraph',
    children: [ { type: 'text', value: ':::', position: [Object] } ],
    position: { 省略 }
}
```

これだけでもかなり面倒に思えたが、前述のようにネストさせて書くと、これの前後に同様なオブジェクトが並列にくっ付いてくる。うーん、カス！ｗ

mdast の構造について記しておく。まず一番頭に `Root` がある。子要素は `children` として配列で格納されている。ゆえに上の `paragraph` は、次のような多分木の構造の中にある：

```
Root -> [{paragraph -> text}, {paragraph -> text}, ...]
```

`unist-util-visit-parent` で `text` だけを見る実装にしたと述べた。この場合、 `details` 記法で生成された `text` は必ず深さ 2 の場所にある。更に、`visitor` の第 2 引数には `root` と 親の `paragraph` がこの順に配列で渡される。ゆえに、 `root` の children を見れば親の `paragraph` の index も分かる。

`unist-util-visit` なら index も貰えるのだが、この index は親の children 配列における自身の位置だから、 `paragraph` を全部見なくてはならなくなる。すると中身の `text` にアクセスする際に `node.children[0].value` などとしなくてはならず、非常に煩雑である。最初はこっちを使っていて大変なことになった。これが `text` だけを見るようにした理由である。

ちなみに、間のノードを付け替えた時点で元の mdast から要らないノードを消そうとすると DFS が止まってしまう問題があった。そのため、付け替え時に適当なフラグを立てておき、全体の処理が終わった後にもう一度探索して要らないノードを削除している。削除用のライブラリ `unist-util-remove` もあるんだから便利なものである。

さらに TypeScript に多数の怒られを頂戴しているが、完全に無視している。俺にはまだ早い。

## MDAST → HAST → HTML

`remark-html` がこれらの変換を担っている。独自のノードを正しく HTML に変換するために、ハンドラーを実装する必要がある。これはドキュメント通りに書けばなんとかなったので、 md → mdast より苦労せずに済んだ。

`<details>` は `<summary>` とセットで使われることがほとんどだろう。しかも `<summary>` は子要素である。さらに最初の方に適当に埋め込んだ title を `<summary>` の子要素にする必要もある。

mdast に用意したノードは `details` だったから、これをまず `<details>` に変換することとする。さらに子要素をいい感じに加工して `summary` ノードを作り上げる。その後 `summary` ノードを `<summary>` に変換するハンドラーも書く。合計 2 つものハンドラーが必要であった。えーーーーーーーーーーーーーーーーーーーー

まあちゃんと実装できたので良かったです

## 今後の展望

`message` も `alert` も似たように実装できるだろうから、それをやる。記法もほとんど同じだから、おそらく今回実装した機能を別のモジュールに切り分けることになるだろう。

また、今回は HTML に変換しただけであるから、React DOM に変換した後に Chakra UI を適用させることもやらねばならない。

ゆくゆくは OG を取ってこれるようなカードも実装するだろう。ツイートや YouTube の埋め込みにも対応したい。KaTeX も入れよう。MathJax はダメ。
